---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---
# Introduction

This document is an attempt to solve the wave equation and generate a snapshot matrix for dimensionality reduction to be applied on it. The following is an excerpt describing the wave equation. 

The wave equation is a very important partial differential equation, of the hyperbolic type, describing the motion of a wave front. It is used in e.g. acoustic and fluid dynamics and has the following form:
$$\frac{\delta ^2 u}{\delta t ^ 2} = \nabla \cdot (c^2 \nabla u)$$

In order to get a better picture, we can model this equation in 3-dimensions using the following formulation: 

$$\frac{\delta ^2 u}{\delta t ^ 2} = c^2 (\frac{\delta ^2 u}{\delta x ^2} + \frac{\delta ^2 u}{\delta y ^2} + \frac{\delta ^2 u}{\delta x ^2})$$ 

For now, we are going to stick to the 1-Dimensional formulation of the problem. A description of the instance of a pulse travelling through a stretched string. 

$$\frac{\delta ^2 u}{\delta t ^ 2} = c^2 \frac{\delta ^2 u}{\delta x ^2}$$
# Implementation of the Wave Equation

```{r, message=FALSE, warning=FALSE}
library(ReacTran)
library(deSolve)
library(tidyverse)
```

Boundary conditions to make the problem solvable: 

$$
\begin{aligned}
u&(t, -\infty)  &=0 \\
u&(t, \infty) &= 0
\end{aligned}
$$
Initial conditions: 

$$
\begin{aligned}
u(0,x) =& exp(-\lambda x^2) \\
\frac{\delta u}{\delta t}_{0,x} =& 0
\end{aligned}
$$


```{r}
# defining box sizes and a grid
dx <- 0.2
xgrid <- setup.grid.1D(x.up = -100, x.down = 100, dx.1 = dx) 
x <- xgrid$x.mid
N <- xgrid$N
```

```{r}
#initial conditions, a gaussian pulse
lam  <- 0.05
uini <- exp(-lam*x^2)
vini <- rep(0, N)
yini <- c(uini, vini)
times <- seq(from = 0, to = 50, by = 1)
```

The wave equation function (wave) first extracts, from the state variable vector y the two quantities u, v, both of length N, after which the ReacTran function tran.1D() performs transport of u; the squared velocity (c2) is taken as 1 (D = 1).

The function returns the derivatives of both u and v, combined (c()) and packed as a list.

```{r}
wave <- function (t, y, parms) { 
  u <- y[1:N]   
  v <- y[(N+1):(2*N)]
  du <- v
  dv <- tran.1D(C = u, C.up = 0, C.down = 0, D = 1,dx = xgrid)$dC
  return(list(c(du, dv))) 
}
```


```{r}
# solving with the "adams method"
out <- ode.1D(func = wave, y = yini, times = times, parms = NULL, 
              method = "adams", dimens = N, names = c("u", "v")) 
u <- subset(out, which = "u")
v <- subset(out, which = "v")
```


```{r}
outtime <- seq(from = 0, to = 50, by = 10) 
# plot
matplot.1D(out, which = "u", subset = time %in% outtime,
           grid = x, xlab = "x", ylab = "u", type = "l", 
           lwd = 2, xlim = c(-50, 50), col = c("black", rep("darkgrey", 5)))
# adjust legend
legend("topright", lty = 1:6, lwd = 2, col = c("black", rep("darkgrey", 5)), 
       title = "t = ", legend = outtime)
```

```{r}
# analytical solution for future reference

# analytic <- function (t, x){
#   0.5 * (exp(-lam * (x+1*t)^2 ) +exp(-lam * (x-1*t)^2) )
# }
# 
# OutAna <- outer(times, x, FUN = analytic)
```



Now, the snapshot matrix can be created.

```{r}
#creating the snapshot matrix
out_df <- as.data.frame(out)

#writing this dataframe to a csv
write.csv(out_df, "data/wave_1D_snapshot.csv")
```


# Dimensionality Reduction

```{r} 
#computing the SVD
SVD <- svd(out_df)

#getting a new POD basis using the first 10 columns for now
pod_basis <- SVD$u[, 1:10]
```



```{r Solving the ROM variant}
# going to be making a comparison between the ROM and the FOM 
u_ROM <- uini

A_ROM <- SVD$u %*% diag(SVD$d) %*% t(SVD$v)

# creating a function to get the ROM solution
# running into a problem here, when solving the function, getting mismatched dimensions
# think this is from the A_ROM definition above, but when i subset to include only the new basis columns, I get errors there too.
rom_solution <- function(pod_basis){
  rhs_red <- u_ROM[2:(length(u_ROM)-1)]
  
  rhs_ROM <- t(pod_basis)*rhs_red
  u_ROM_sol <- mldivide(diag(SVD$d[10,]), rhs_ROM)
  u_ROM_new <- pod_basis*u_ROM_sol
}

rom_solution(pod_basis)
```



```{r}
#benchmarking
benchmark("ROM" = {rom_solution(pod_basis)},
          
          "FOM" = {out <- ode.1D(func = wave, y = yini, times = times, parms = NULL, 
                                  method = "adams", dimens = N, names = c("u", "v")) },
          replications = 1000,
          columns = c("test", "replications", "elapsed",
                      "relative", "user.self", "sys.self"))
```











